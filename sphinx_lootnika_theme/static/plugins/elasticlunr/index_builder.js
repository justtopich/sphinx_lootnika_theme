var index = elasticlunr(function () {
  this.use(lunr.multiLanguage('en', 'ru'));
  
  this.setRef('url1');
  this.addField('url0');
  this.addField('title');
  this.addField('head');
  this.addField('body');
});

// python indexBuilder
const docs = [
{'url0': '/', 'url1': '/', 'title': '', 'head': 'Справка ASKID Connector', 'body': ' ASKID Connector предназначен для импорта данных из АСКИД в СПАНД (платформа IDOL). Приложение позволяет выполнять Select запросы в базы данных MySQL, выгружать файлы с веб-серверов и формировать xml документы для их дальнейшей обработки в модулях платформы IDOL.  Здесь собраны все доступные возможности, описания и примеры их использования. Все знания разделены на следующие разделы:    Настройки  - описание параметров   Команды  - описание REST API   --   /Actions  - управление коннетором  --   /Shedule  - управление заданиями  --   --    По замечаниям, найденным ошибкам или предложениям пишите на почту  aleksandr.beloglazov@redsys.ru  '},
{'url0': '/config', 'url1': '/config', 'title': '', 'head': 'Настройки', 'body': ' Все параметры хранятся в конфигурационном файле  askid.cfg . Если он отсутствует,то коннектор создаст его при запуске. В таком случае, в него будут записаны все необходимые параметры и демонстрационное задание. На его основе можно быстро сконфигурировать коннектор и начать его использовать, но прежде стоит изучить параметры и ознакомиться с   синтаксисом  . '},
{'url0': '/config/syntax', 'url1': '/config/syntax', 'title': '', 'head': 'Синтаксис настроек', 'body': ' Конфигурационный файл состоит из секций, в котором есть параметры относящейся к ней. Имеет следующую структуру:         [Секция1]     Параметр1= значение    Параметр2= значение      [Секция2]     Параметр1= значение    Параметр2= значение     ; комментарий     # это тоже комментарий         Название каждой секции обозначено квадратными скобками (например,  [License] ). Секции не должны повторяться и могут находится в любом порядке. Параметр относится к секции до тех пор, пока не будет объявлена новая. Значения параметров пишутся в одну строку.   В параметрах при указании путей используйте обратные слешы  /  вместо  \\  Если в пути есть пробелы - укажите его в кавычках:  home\\var load\\askidConnector   Файл должен быть в кодировке UTF-8. '},
{'url0': '/config/server', 'url1': '/config/server', 'title': '', 'head': 'Секция Server', 'body': ' Здесь задаются параметры использования  REST API :     Host    Port    QueryClients    AdminClients    '},
{'url0': '/config/server', 'url1': '/config/server#host', 'title': 'Host', 'head': 'Секция Server', 'body': ' Задаёт адрес на котором коннектор будет ожидать команды. Можно использовать как IP адрес, так DNS имя. Коннектор будет принимать команды только по заданному адресу.        host= localost   host= 172.22.16.54        '},
{'url0': '/config/server', 'url1': '/config/server#port', 'title': 'Port', 'head': 'Секция Server', 'body': ' Задаёт порт на котором он будет ожидать команды. Этот порт используется как для управления коннектором, так и для управления заданиями.        port= 7252        '},
{'url0': '/config/server', 'url1': '/config/server#QueryClients', 'title': 'QueryClients', 'head': 'Секция Server', 'body': ' Список адресов для которых разрешено выполнять  общие команды . Все входящие команды от клиентов вне этого списка будут отклонены.  Можно использовать как IP адрес, так DNS имя или укажите  *  чтобы дать разрешения всем. Разделитель  ;  используется для перечисления нескольких адресов.        QueryClients= *   QueryClients= localhost; 172.22.16.54;myserver        '},
{'url0': '/config/server', 'url1': '/config/server#AdminClients', 'title': 'AdminClients', 'head': 'Секция Server', 'body': ' Список адресов для которых разрешено выполнять  контрольные команды . Все входящие команды от клиентов вне этого списка будут отклонены.  Указанные здесь клиенты уже имеют уровень доступа  QueryClients и добавлять их туда не имеет смыла. Указывайте здесь только те адреса, с которых необходимо управлять коннектором.  Можно использовать как IP адрес, так DNS имя или укажите  *  чтобы дать разрешения всем. Разделитель  ;  используется для перечисления нескольких адресов.        AdminClients= *   AdminClients= localhost; 172.22.16.54;myserver        '},
{'url0': '/config/Service', 'url1': '/config/Service', 'title': '', 'head': 'Секция Service', 'body': ' Параметры службы Windows.  Данные параметры используются для установки\\удаления\\изменения службы коннектора. Вы можете создать службу для коннектора, что позволит ему работать вне зависимости от статуса пользователя, а так же задать параметры автоматического запуска, от имени какого пользователя запускать и т.д.  Установка, удаление и изменение служб производится через исполняемый файл коннектора с правами администратора. Доступны следующие параметры:    Name    DisplayName    Description    '},
{'url0': '/config/Service', 'url1': '/config/Service#Name', 'title': 'Name', 'head': 'Секция Service', 'body': ' Имя службы. Оно используется для идентификации службы и будет отображаться в диспетчере задач.        Name =  AskidConnectorSvc        '},
{'url0': '/config/Service', 'url1': '/config/Service#DisplayName', 'title': 'DisplayName', 'head': 'Секция Service', 'body': ' Название службы которое будет отображаться в диспетчере служб.        DisplayName =  Askid Connector Service       '},
{'url0': '/config/Service', 'url1': '/config/Service#Description', 'title': 'Description', 'head': 'Секция Service', 'body': ' Описание службы.        Description =  IDOL connector for ASKID        '},
{'url0': '/config/DiskUsage', 'url1': '/config/DiskUsage', 'title': '', 'head': 'Секция DiskUsage', 'body': ' Отслеживание свободного места на диске сервера.  Во время выполнения заданий коннектор скачивает документы для отправки их в CFS. Если по каким-то причинам CFS не будет доступен или он будет не успевать обрабатывать документы и т.п., то скачанные файлы будут накапливаться во временной папке, что может привести к заполнению диска сервера. Для избежания такой ситуации укажите диск на котором находится временная папка коннектора.  Если во время выполнения задания будет достигнут лимит свободного места, то коннектор приостанавливает работу и в течении  30 минут  будет в режиме ожидания. Если по истечению этого времени свободное места так и не станет больше заданного лимита - коннектор остановит выполнение текущего задания.  Эта функция используется только во время выполнения заданий, в которых активен параметр   GetFiles  . Коннектор проверяет свободное место перед каждой загрузкой очередного файла.  Данные настройки задаются в секции  [DiskUsage] .     PathWatch    CritFreeGb    '},
{'url0': '/config/DiskUsage', 'url1': '/config/DiskUsage#PathWatch', 'title': 'PathWatch', 'head': 'Секция DiskUsage', 'body': ' Диск, за свободным местом которого необходимо следить.         PathWatch =  C:/        '},
{'url0': '/config/DiskUsage', 'url1': '/config/DiskUsage#CritFreeGb', 'title': 'CritFreeGb', 'head': 'Секция DiskUsage', 'body': ' Размер минимального свободного места. Измеряется в Гб.         CritFreeGb =  10        '},
{'url0': '/config/Schedule', 'url1': '/config/Schedule', 'title': '', 'head': 'Секция Schedule', 'body': ' Управление расписанием выполнения заданий.  Коннектор имеет встроенную функцию планировщика заданий для  их периодического выполнения. Каждое такое выполнение называется циклом. Цикл может состоять от одного до нескольких заданий. Если задание не может быть выполнено, планировщик приступит к следующему. Цикл будет завершён как только все задания будут закончены. После каждого цикла планировщик либо завершает выполнение расписания, либо ждёт заданное время до следующего цикла.  Список доступных параметров:     Enable    TaskStartTime    TaskCycles    RepeatMin    TaskCount     Все параметры относятся к расписанию и не могут быть применены к отдельно взятым заданиям. Например, вы не можете указать разное время старта для разных заданий. Очерёдность выполнения заданий определяется в параметре  TaskCount  '},
{'url0': '/config/Schedule', 'url1': '/config/Schedule#Enable', 'title': 'Enable', 'head': 'Секция Schedule', 'body': ' Булевое значение отвечающее за активацию расписания. При использовании  False  нижеописанные параметры будут не активны, а начать выполнение заданий можно только с помощью команды  Schedule .       Enable= True        '},
{'url0': '/config/Schedule', 'url1': '/config/Schedule#TaskStartTime', 'title': 'TaskStartTime', 'head': 'Секция Schedule', 'body': ' Указывает время старта циклов заданий. Можно указать конкретное время или старт при запуске коннектора. Время указывается в 24-часовом формате  HH:MM:SS         TaskStartTime= now   TaskStartTime= 15:50:30        '},
{'url0': '/config/Schedule', 'url1': '/config/Schedule#TaskCycles', 'title': 'TaskCycles', 'head': 'Секция Schedule', 'body': ' Количество выполнений расписания. Если укажите  0 , то расписание выполняться не будет, а если  -1  - будет повторятся бесконечно.        TaskCycles= -1        '},
{'url0': '/config/Schedule', 'url1': '/config/Schedule#RepeatMin', 'title': 'RepeatMin', 'head': 'Секция Schedule', 'body': ' Временной интервал между циклами заданий. Этот интервал отсчитывается от старта каждого цикла. Если на момент старта очередного цикла предыдущий ещё будет выполняться, то коннектор пропустит его и начнёт новый отсчёт до следующего цикла.  При этом он всё равно будет засчитан в счётчик  TaskCycles         RepeatMin= 4320    ; повтор каждые три дня        '},
{'url0': '/config/Schedule', 'url1': '/config/Schedule#TaskCount', 'title': 'TaskCount', 'head': 'Секция Schedule', 'body': ' Количество и порядок выполнения заданий. Вы можете задать в расписании минимум одно задание. Значение этого параметра не должно превышать количество заданий, но может быть меньше. Отсчёт заданий начинает от  0  и выполняются в порядке возрастания.        TaskCount= 2   0= Prikaz   1= Prikaz_files   2= Не_исплоьзуется         Задания можно выполнить с помощью команд только если они будут здесь объявлены. Для того, чтобы узнать какие задания доступны для выполнения, используйте команду  Schedule: TasksInfo  '},
{'url0': '/config/Downloader', 'url1': '/config/Downloader', 'title': '', 'head': 'Секция Downloader', 'body': ' Загрузка файлов по HTTP.  Эта функция используется только во время выполнения заданий, в которых активен параметр   GetFiles    Коннектор может забирать данные не только из MySQL, но и ещё выкачивать файлы с web серверов по протоколу  HTTP/HTTPS . При успешной загрузки он связывает файлы с документами и после отправляет на индексацию.  Ссылки на документы задаются через шаблоны в которых можно использовать поля документов.  Получив все поля документа из БД источника, коннектор по шаблону создаст ссылку и выполнит загрузку файла. Потому, для одного документа можно загрузить лишь один файл. В ином случае создайте отдельное задание для получение всех ID файлов и их загрузки.   Загрузчики проверяют свободное место перед каждой загрузкой очередного файла. Критерии проверки задаются в секции   [DiskUsage]   При успешном скачивании загрузчик добавит в документ поле  Web-Cnt-Length  в котором будет записано значение заголовка  Content-Length . Название секции должно совпадать с названием заданным в задании в параметре   Downloader  . Доступны следующие параметры:    UseLogon    LogonUrl    LogonVerify    VerifyTerm    WebUsr    WebPsw    GetLink    PathFiles    FailDwnld    '},
{'url0': '/config/Downloader', 'url1': '/config/Downloader#UseLogon', 'title': 'UseLogon', 'head': 'Секция Downloader', 'body': ' Булевое значение отвечающее за авторизацию. Если для скачивания файла требуется вход на web сервер - укажите  True         UseLogon =  True        '},
{'url0': '/config/Downloader', 'url1': '/config/Downloader#LogonUrl', 'title': 'LogonUrl', 'head': 'Секция Downloader', 'body': ' Если вы используете  UseLogon , укажите адрес по которому коннектор будет проходить авторизацию.  После успешной авторизации коннектор создаёт сессию в рамках которой будет выполнять загрузку файлов.Если при загрузки файла время сессии истекло или web сервер возвращает код ошибки  401  - коннектор будет использовать данную ссылку для повторной авторизации.        LogonUrl =  https://filerepo/Login       '},
{'url0': '/config/Downloader', 'url1': '/config/Downloader#LogonVerify', 'title': 'LogonVerify', 'head': 'Секция Downloader', 'body': ' Если вы используете  UseLogon , укажите метод проверки успеха авторизации.  Для проверки обычно используются HTTP статусы, которые web сервер возвращает в заголовках.  Успешным является статус 200 , потому по умолчанию используется именно он. После  трёх  неудачных попыток задание завершится с ошибкой и коннектор начнёт следующее задание.   Но некоторые сайты могут возвращать успешный статус даже при неудачной авторизации. Например, если сервер для ответов использует JSON и статус отдаёт в нём, а не в заголовках. Тогда можно проверять не статус, а содержимое ответа задав значение  text . В этом случае коннектор будет переводить ответ в текст и искать в нём заданное выражение. В ином случае используйте  status .  Например, вы можете указать страницу куда доступ имеют только авторизованные пользователи (по типу личного кабинета) и искать заданный текст на странице.        LogonVerify =  status   LogonVerify =  text        '},
{'url0': '/config/Downloader', 'url1': '/config/Downloader#VerifyTerm', 'title': 'VerifyTerm', 'head': 'Секция Downloader', 'body': ' Статус или текст который ожидается при успешной авторизации.        VerifyTerm =  200   VerifyTerm =  выйти        '},
{'url0': '/config/Downloader', 'url1': '/config/Downloader#WebUsr', 'title': 'WebUsr', 'head': 'Секция Downloader', 'body': ' Логин для авторизации на web сервере.        WebUsr =  BotBot        '},
{'url0': '/config/Downloader', 'url1': '/config/Downloader#WebPsw', 'title': 'WebPsw', 'head': 'Секция Downloader', 'body': ' Пароль от логина из параметра  WebUsr .        WebPsw =  PassPass        '},
{'url0': '/config/Downloader', 'url1': '/config/Downloader#GetLink', 'title': 'GetLink', 'head': 'Секция Downloader', 'body': ' Шаблон для создания ссылок на файлы.  В шаблоне можно использовать поля документов которые были получены при выполнении SQL запросов. Для этого оберните их в  @ .        GetLink =  https://filerepo/storage/id/  @id@     GetLink =  http://filerepo/file/  @user_id@  /upload/  @file_id@  .zip        '},
{'url0': '/config/Downloader', 'url1': '/config/Downloader#PathFiles', 'title': 'PathFiles', 'head': 'Секция Downloader', 'body': ' Путь каталога в который будут сохраняться файлы.  Поскольку загруженные документы  забирает и удаляет CFS  - он должен иметь доступ к этому каталогу и права на чтение\\удаление файлов в нём.        PathFiles =  Downloads/   PathFiles =  E:/temp/documents/        '},
{'url0': '/config/Downloader', 'url1': '/config/Downloader#FailDwnld', 'title': 'FailDwnld', 'head': 'Секция Downloader', 'body': ' Текстовый файл в который будут записываться id файлов которые не удалось загрузить.  Данный файл используется лишь для быстрой отладки проблемных файлов. Список id перечисляются через  ;          FailDwnld =  FailDownloadDoc.txt        '},
{'url0': '/config/Task', 'url1': '/config/Task', 'title': '', 'head': 'Секция Task', 'body': ' Настройка параметров заданий.  Каждое задание должно быть свою секцию. Название секции должно совпадать со значением объявленное в   [Schedule]    Здесь доступны следующие параметры:     IdolDb    DocRef    DBhost    DBport    DBscheme    DBusr    DBpsw    NotNullRows    SelectSize    SelectID    SelectMeta    SelectComplete    GetFiles    Downloader    '},
{'url0': '/config/Task', 'url1': '/config/Task#IdolDb', 'title': 'IdolDb', 'head': 'Секция Task', 'body': ' База данных IDOL в которую будут индексироваться документы.        IdolDb= askid_docs        '},
{'url0': '/config/Task', 'url1': '/config/Task#DocRef', 'title': 'DocRef', 'head': 'Секция Task', 'body': ' Шаблон создания идентификаторов документов типа Reference. Reference должен быть уникальным для каждого документа. В нём можно использовать метаданные самого документа, например: его id, номер, название и т.д. Используйте только те поля, которые  всегда  присутствуют документе. Если нужного поля не окажется в метаданных , то документ  не будет создан , а значит не будет передан в CFS на обработку и проиндексирован в IDOL. Если документ не имеет уникальных полей, используйте комбинацию различных полей и других указателей. Не допускайте попадания спецсимволов или символов не входящих в ASCII кодировку (иероглифы, кириллица). Документы с таким Referece могут некорректно обрабатывается в модулях платформы IDOL. Если нет возможности 100% это предотвратить, используйет  Lua скрипты  в CFS для кодирования Reference. Например, в  Base64. Чтобы подставлять нужное поле из метаданных оберните его в  @ .       DocRef= askid_docs_ @id@    DocRef= document_ @number@    DocRef=  @id@ - @name@ - @data@         '},
{'url0': '/config/Task', 'url1': '/config/Task#DBhost', 'title': 'DBhost', 'head': 'Секция Task', 'body': ' IP адрес или DNS имя база данных типа MySQL источника.        dbHost= 192.291.11.22   dbHost= RepoServer        '},
{'url0': '/config/Task', 'url1': '/config/Task#DBport', 'title': 'DBport', 'head': 'Секция Task', 'body': ' Номер порта базы данных источника.        dbPort= 3306        '},
{'url0': '/config/Task', 'url1': '/config/Task#DBscheme', 'title': 'DBscheme', 'head': 'Секция Task', 'body': ' Название схемы таблиц в базе данных источника.        dbScheme= askid55        '},
{'url0': '/config/Task', 'url1': '/config/Task#DBusr', 'title': 'DBusr', 'head': 'Секция Task', 'body': ' Учётная запись которая будет использоваться для подключения к базе данных источника.        DBusr= askidBot        '},
{'url0': '/config/Task', 'url1': '/config/Task#DBpsw', 'title': 'DBpsw', 'head': 'Секция Task', 'body': ' Пароль для учётной записи используемой для подключения к базе данных источника.        DBpsw= Qwerty123        '},
{'url0': '/config/Task', 'url1': '/config/Task#NotNullRows', 'title': 'NotNullRows', 'head': 'Секция Task', 'body': ' Булевое значение отвечающее за запрет пустых строк. При активации этого параметра, если запрос вернёт пустую строку, коннектор подставит для каждого поля значение  @null@ .        NotNullRows= False         Эта опция действует только когда  вся строка  вернётся пустой. Если необходимо выполнить подстановку для конкретного поля - используйте  IFNULL  в SQL запросах. '},
{'url0': '/config/Task', 'url1': '/config/Task#SelectSize', 'title': 'SelectSize', 'head': 'Секция Task', 'body': ' Количество запрашиваемых ID документов.  Для выполнения SQL запросов коннектор вначале должен получить ID документов, к которым эти запросы относятся. Коннектор может запрашивать их не все сразу, а порционно. Это позволит снизить нагрузку на сервер БД если в ней очень много документов.  Например, при  SelectSize=1000  коннектор будет запрашивать по тысячи документов и для каждого выполнит задание (SQL запросы, загрузка файлов, отправка на CFS и т.д.). Как только эта пачка документов будет обработана, коннектор запросит следующую тысячу ID.        SelectSize= 3000         Эта опция работает только при условии, что возвращаемые ID являются числами. '},
{'url0': '/config/Task', 'url1': '/config/Task#SelectID', 'title': 'SelectID', 'head': 'Секция Task', 'body': ' SQL запрос для получения ID документов.  Полученные ID используются в запросах  SelectMeta . Запрос  обязательно  должен возвращать только один столбец с названием  id .        SelectID= SELECT user_posts AS id FROM blog.tasks   SelectID= SELECT id FROM blog.tasks         Обратите внимание что конец запроса не обязательно обозначать символом  ;  - коннектор сам его поставит. '},
{'url0': '/config/Task', 'url1': '/config/Task#SelectMeta', 'title': 'SelectMeta', 'head': 'Секция Task', 'body': ' SQL запрос для получения метаданных документа.  Каждый документ полученный запросом  SelectID   уже имеет поле id , таким образом это поле можно  использовать во всех последующих  запросах. Это относится ко всем полям документа. Возвращаемые данные добавляются к метаданным документа и в виде полей и их названия будут соответствовать названиям столбцов из результатов запроса.  Для каждого документа можно выполнять любые SQL запросы подставляя в них его поля. Для этого оберните их в  @ . Количество запросов не ограничено и начинаются с  SelectMeta0 . В одном таком параметре может быть только один запрос.        SelectMeta0= SELECT user_id AS task_user_id FROM blog.tasks WHERE id= @id@    SelectMeta1= SELECT nickname FROM blog.users WHERE id= @task_user_id@          Если запрос вернёт поле с названием, которое уже есть в документе - это поле будет перезаписано. Чтобы такого не происходило, давайте другие имена этим столбцам как показано в  SelectMeta0 .  После вышеприведённого примера документ будет иметь следующую структуру:        {    id :  535 ,    task_user_id :  88 ,    nickname :  Счастливчик   }        Все запросы заданные в  SelectMeta X   называются цепочкой основных запросов или запросы из основной ветви. Каждый такой запрос, словно звено одной цепи, выполняется последовательно один за другим используя поля полученные на предыдущих звеньях этой цепи. Но у них есть ограничения - в них  нельзя  подставить поле, если оно является массивом, т.е. предыдущее звено вернуло несколько строк.  Что же тогда делать если такой запрос вернёт несколько строк и по каждой из них нужно выполнить друге запросы? В таком случае создайте ещё одну цепь или  дополнительную ветвь  SQL запросов. Они так же могут использовать все поля документа и самое главное - в отличии от основных запросов, они будут выполняться  для каждого  элемента массива. Рассмотрим пример:       SelectMeta0= SELECT user_id AS task_user_id FROM blog.tasks WHERE id= @id@    SelectMeta1= SELECT id AS post_id FROM blog.posts WHERE task_id= @id@  AND user_id= @task_user_id@          Допустим,  SelectMeta1  вернёт несколько строк, а значит поле  post_id  будет массивом:        {    id :  535 ,    task_user_id :  88 ,    post_id : [ 10 , 11 ]  }        Использовать это поле в  SelectMeta2  не получится, а потому сделайте ответвление от основного запроса. Для этого создадим параметр с названием  SelectMeta1-0 , где дефис означает подзапрос, а ноль - его порядковый номер.  Теперь для каждого сообщения пользователя мы получим его текст и вложенные файлы:        SelectMeta0= SELECT user_id AS task_user_id FROM blog.tasks WHERE id= @id@    SelectMeta1= SELECT id AS post_id FROM blog.posts WHERE task_id= @id@  AND user_id= @task_user_id@    SelectMeta1-0= SELECT message FROM blog.posts WHERE id= @post_id@    SelectMeta1-1= SELECT id AS file_id FROM blog.files WHERE post_id= @post_id@    SelectMeta2= SELECT nickname FROM blog.users WHERE id= @task_user_id@          Обратите внимание, что в  SelectMeta1-1  столбец  id  был переименован в  file_id , a в  SelectMeta1  - в  post_id . Так сделано для того, чтобы они не перезаписали друг друга. Это не является обязательным если это поле более нигде не нужно или вас устроит что там будет перезаписано значение.  В результате вместо поля  post_id  появилось  subMeta1-0  которое является тем же массивом, но состоящее не из значений, а из вложенных документов со своими полями. Помимо этого, запрос  SelectMeta1-1  вернул ещё один массив  file_id :        {    id :  535 ,    task_user_id :  88 ,    subMeta1-0 : [      {post_id :  10 ,       message :  Продам гараж! ,       file_id : [ 123 , 456 , 789 ]      },      {post_id :  11 ,       message :  Снижаю цену!!       }    ],    nickname :  Артур Пирожков   }        Таким образом можно сказать, что в документе с  id=535  есть пользователь  task_user_id=88  с  nickname=Артур Пирожков , который оставил  2  сообщения с  post_id=10  и  post_id=11 , и что в первом сообщении пользователь приложил  3  файла с  file_id=[123,456,789] .  В конечном счёте в CFS отправится документ, поля в котором будут перечислены в том порядке, в котором они добавлялись в метаданные документа. При этом каждый элемент массива будет сохранён в отдельное поле с тем же именем. Условно говоря:        STARTDOC  FIELD id  =  535   FIELD task_user_id  =  88   FIELD post_id  =  10   FIELD message  =  Продам гараж!   FIELD file_id  =  123   FIELD file_id  =  456   FIELD file_id  =  789   FIELD post_id  =  11   FIELD message  =  Снижаю цену!!   FIELD nickname  =  Артур Пирожков   ENDDOC       В документе отсутствуют поля  subMeta1-0 , хотя это поле тоже является массивом. Вместо элементов оно содержит объекты, а потому в документ были поочерёдно добавлены их поля.  Запросы из дополнительной ветви имеют свои ограничения: ❖ для них нельзя добавить ещё одну ветвь запросов типа  SelectMeta1-1-0  ❖ они могут использовать поля  только  из основной ветви или из своего объекта. ❖ они могут переписать поля  только  внутри своего объекта. '},
{'url0': '/config/Task', 'url1': '/config/Task#SelectComplete', 'title': 'SelectComplete', 'head': 'Секция Task', 'body': ' SQL запрос который заменяет  SelectID и  SelectMeta . Если все id документов и их поля можно получить одним запросом - используйте этот параметр. В таком случае каждая строка будет сохранена в IDOL как отдельный документ.        SelectComplete= SELECT id, name, number, date, size FROM blog.files         В этом параметре так же обязательно наличие столбца  id . '},
{'url0': '/config/Task', 'url1': '/config/Task#GetFiles', 'title': 'GetFiles', 'head': 'Секция Task', 'body': ' Булевое значение отвечающее за использование загрузчика файлов документов. При его использовании коннектор будет загружать файлы с web-сервера и прикреплять их к документам.       GetFiles= True        '},
{'url0': '/config/Task', 'url1': '/config/Task#Downloader', 'title': 'Downloader', 'head': 'Секция Task', 'body': ' Название секции в которой хранятся параметры загрузчика. Для каждого задания можно настроить свой загрузчик файлов с разными параметрами.  Для одного задания можно использовать только один загрузчик. Его параметры описаны в следующем разделе  [Downloader]         Downloader= Post_files        '},
{'url0': '/config/Ingest', 'url1': '/config/Ingest', 'title': '', 'head': 'Секция Ingest', 'body': ' Отправка документов на обработку и индексирование.  Здесь задаются параметры отправки документов в IDOL ConnectorFrameworkServer. Если коннектор не сможет их отправить или CFS вернёт неверный статус, то они будут сохранены в отдельной папке. В ней для  каждого задания каждого цикла  создаётся своя папка в которой хранятся xml файлы с метаданными документов. Доступны следующие параметры:    CFShost    CFSport    CfsBatchSize    XmlPath    '},
{'url0': '/config/Ingest', 'url1': '/config/Ingest#CFShost', 'title': 'CFShost', 'head': 'Секция Ingest', 'body': ' IP адрес или DNS имя CFS.        CFShost =  10.0.2.211   CFShost =  serverCFS.ru        '},
{'url0': '/config/Ingest', 'url1': '/config/Ingest#CFSport', 'title': 'CFSport', 'head': 'Секция Ingest', 'body': ' Номер порта CFS.        CFSport =  7200       '},
{'url0': '/config/Ingest', 'url1': '/config/Ingest#CfsBatchSize', 'title': 'CfsBatchSize', 'head': 'Секция Ingest', 'body': ' Количество документов для отправки в CFS.  Чем больше метаданных в документах, тем меньше указывайте размер очереди.        CfsBatchSize =  200        '},
{'url0': '/config/Ingest', 'url1': '/config/Ingest#xmlpath', 'title': 'XmlPath', 'head': 'Секция Ingest', 'body': ' Директория сохранения xml файлов, которые не удалось отправить на CFS.  Коннектор будет создавать уникальную папку для каждого исполняемого экземпляра задания. Если одно задание выполнялось 3 раза и при каждом выполнении CFS был недоступен, то будут созданы 3 папки содержащие готовые для отправки на CFS xml документы. Вы сможете сами отправить их на обработку без необходимости повторного выполнения задания.        XmlPath= SendFail/        '},
{'url0': '/config/Logging', 'url1': '/config/Logging', 'title': '', 'head': 'Секция Logging', 'body': ' Журналирование событий.  Настройка журналов событий работы коннектора и хода выполнении заданий. Доступны следующие параметры:     Enable    LogLevel    LogMaxSizeKbs    LogMaxFiles    '},
{'url0': '/config/Logging', 'url1': '/config/Logging#Enable', 'title': 'Enable', 'head': 'Секция Logging', 'body': ' Булевое значение отвечающее за активацию журналирования. При использовании  False  коннектор не будет вести никаких записей, но они всё равно будут выводится в консоль.        Enable =  True        '},
{'url0': '/config/Logging', 'url1': '/config/Logging#LogLevel', 'title': 'LogLevel', 'head': 'Секция Logging', 'body': ' Уровень событий которые будут записаны.  Доступно два уровня:  Full  - запись всех событий включая debug.  Normal  - запись событий уровня info и выше.        LogLevel =  Full       '},
{'url0': '/config/Logging', 'url1': '/config/Logging#LogMaxSizeKbs', 'title': 'LogMaxSizeKbs', 'head': 'Секция Logging', 'body': ' Максимальный размер файла журнала.  При достижении заданного лимита запись начнётся в новый файл, а предыдущий будет переименован.        LogMaxSizeKbs =  200        '},
{'url0': '/config/Logging', 'url1': '/config/Logging#LogMaxFiles', 'title': 'LogMaxFiles', 'head': 'Секция Logging', 'body': ' Максимальное количество файлов журнала.  При достижении заданного лимита коннектор будет удалять самые первые переименованные файлы.        LogMaxFiles =  50        '},
{'url0': '/api', 'url1': '/api', 'title': '', 'head': 'Команды', 'body': ' Описание REST API.  Предоставляемое API позволяет управлять коннектором и получать сведения о статусе его работы. Управление происходит через отправку http запросов на TCP порт коннектора. Такие запросы называются  командами  и делятся на 2 типа:   общие   и   контрольные  .  К  общим  относятся такие команды, как получение статуса работы коннектора или файла из источника. Обычно они доступны всем и потому позволяют выполнить только то, что может понадобиться лишь пользователю. К  контрольным  относятся команды позволяющие получать все сведения о работе коннекторе и контролировать его работу. Обычно они доступны администраторам.  Параметры доступа к API задаются в секции   [Server]   Команды имеют свой   синтаксис  . '},
{'url0': '/api/syntax', 'url1': '/api/syntax', 'title': '', 'head': 'Синтаксис команд', 'body': ' Команды имеют следующий синтаксис:  http://Host:Port/action=ActionName&[Parameters]  Где: ActionName - команда Parameters - параметры команды  Параметры перечисляются через  &   и могут быть в любом порядке. Например, команда на запуск задания под названием DontWork:        http://localhost:7252/action= Schedule & cmd = Start & TaskName = DontWork         Результат коннектор вернёт в формате  json . Например, для вышеописанной команды результат будет такой:        {status:  error , message:  task undefined }        Разные команды возвращают разный результат, admin и help - html страницы, view - файлы, остальные json. Последние всегда содержат поле  status .  Для краткости использования команд вместо   action =ActionName  вы можете использовать   a =ActionName  . '},
{'url0': '/api/common', 'url1': '/api/common', 'title': '', 'head': 'Общие команды', 'body': ' Команды для пользовательского использования.  Для выполнения этих команд клиент должен быть в списке   QueryClients  .     GetStatus    View    '},
{'url0': '/api/common', 'url1': '/api/common#GetStatus', 'title': 'GetStatus', 'head': 'Общие команды', 'body': ' Получение сведений о коннекторе.        action= GetStatus        Вернёт в формате  json  сведения о коннекторе, о клиенте и некоторые параметры:    Поле  Формат  Значение      uptime  Строка  Время работы    product  Строка  Полное название    version  Строка  Версия    directory  Строка  Рабочая папка    service_name  Строка  Название службы    scheduler_status  Строка  Статус планировщика заданий. Может иметь один из следующих статусов:   ready  - готов к новому циклу заданий.   wait  - ждёт время старта следующего повтора.   work  - выполняет цикл заданий.   pause  - планировщик приостановлен пользователем.   cancel  - остановка выполнения текущего цикла заданий      client_host  Строка  Адрес клиента    client_role  Строка  Уровень привилегий клиента    allow_actions  Строка  Доступные команды для клиента    '},
{'url0': '/api/common', 'url1': '/api/common#View', 'title': 'View', 'head': 'Общие команды', 'body': ' Получения файла из источника.  Если в задании используется загрузчик (см.   GetFiles  ), то коннектор будет сохранять ссылку на файл в поле  IDENTIFIER  - его необходимо указывать в параметре  Identifier         action= View & Identifier = PGlkIHM9ImhlbGxvX3Rhc2siIHI9Imh0dHA6Ly9yZXBvL2ZpbGUiLz4=        Для получения файла, в конфигурации коннектора обязательна должна быть секция задания с  тем же названием , при котором он был скачан, а так же указаны актуальные данные для авторизации в секции загрузчика. Чтобы узнать название задания, достаточно декодировать identifier алгоритмом  Base64 . Заданию  необязательно  быть объявленной в параметре  TaskCount  .  Если файл является архивом, вы можете запросить конкретный файл из него. Для этого нужно в конце значения  identifier  указать его индекс в архиве. Индекс указывается после символа  |         action= View & Identifier = PGlkIHM9ImhlbGxvX3Rhc2siIHI9Imh0dHA6Ly9yZXBvL2ZpbGUiLz4=  |0        Извлекать файлы можно так же из архивов внутри других архивов. Для этого нужно перечислить их индексы через знаки |  или  .         action= View & Identifier = PGlkIHM9ImhlbGxvX3Rhc2siIHI9Imh0dHA6Ly9yZXBvL2ZpbGUiLz4=  |0|2  action= View & Identifier = PGlkIHM9ImhlbGxvX3Rhc2siIHI9Imh0dHA6Ly9yZXBvL2ZpbGUiLz4=  |0.2       В данном примере 1-й файл является архивом, и коннектор вернёт из этого архива 2-й файл. Знак вертикальной линии  |  рекомендуется использовать  лишь для обозначения 1-го индекса, а для последующих точку. Это позволит избежать возможных проблем при совместном использовании других коннекторов от IDOL. '},
{'url0': '/api/control', 'url1': '/api/control', 'title': '', 'head': 'Контрольные команды', 'body': ' Команды, которые используются для контроля работы коннектора.     Admin    GRL    Stop    Schedule     TasksInfo    QueueInfo    Start    Pause    Cancel     '},
{'url0': '/api/control', 'url1': '/api/control#Admin', 'title': 'Admin', 'head': 'Контрольные команды', 'body': ' Web интерфейс администратора.  Позволяет управлять коннектором и получать сведения о его работе. Необходимые файлы должны быть в папке  webui\\admin\\ .        action= Admin        '},
{'url0': '/api/control', 'url1': '/api/control#GRL', 'title': 'GRL', 'head': 'Контрольные команды', 'body': ' Просмотр команд отправленных на коннектор.  С момента каждого запуска коннектор сохраняет все команды, адреса клиентов, статус их выполнения и т.д. После перезапуска журнал очищается.        action= grl        '},
{'url0': '/api/control', 'url1': '/api/control#Stop', 'title': 'Stop', 'head': 'Контрольные команды', 'body': ' Остановка коннектора.  Настоятельно рекомендуется останавливать коннектор либо через службу, либо данной командой, либо через консоль комбинацией  ctr+c . При штатной остановке коннектор прекращает выполнять задания, пытается отправить документы в CFS и сохраняет все данные в журналы заданий.        action= Stop        '},
{'url0': '/api/control', 'url1': '/api/control#Schedule', 'title': 'Schedule', 'head': 'Контрольные команды', 'body': ' Управление заданиями.  Вы можете запускать и останавливать задания, а так же следить за ходом их выполнения. Все команды планировщика задания задаются в параметре  cmd  '},
{'url0': '/api/control', 'url1': '/api/control#TasksInfo', 'title': 'Schedule: TasksInfo', 'head': 'Контрольные команды', 'body': ' Получение заданий и их параметров.  Просмотр списка заданий которые коннектор инициализировал и будет выполнять если включено расписание. Если расписание выключено, то запустить их вы сможете только через команду  Start . Чтобы сделать задание доступным - оно должно быть объявлено в секции  [Schedule]: TaskCount         action= Schedule & cmd = TasksInfo        Если для обращения к коннектору используется незащищённый протокол  HTTP , то все значения параметров, содержащие данные учётных записей, заменяются на  *  Чтобы избежать этого, настройте доступ к коннектору по протоколу  HTTPS .  Параметры заданий могут несколько отличаться от таковых в настройках коннектора или вовсе содержать новые. Такое происходит после инициализации задания и нужны для работы коннектора. В настройках эти изменения не сохраняются. '},
{'url0': '/api/control', 'url1': '/api/control#QueueInfo', 'title': 'Schedule: QueueInfo', 'head': 'Контрольные команды', 'body': ' Просмотр журнал заданий.  Получения списка завершённых и текущих заданий, их статуса и прогресса выполнения. По умолчанию вернёт 50 последних записей из журнала.        action= Schedule & cmd = QueueInfo       Команда вернёт следующие поля:    Поле  Формат  Значение      scheduler_status  Строка  Статус планировщика заданий. Может иметь один из следующих статусов:   ready  - готов к новому циклу заданий.   wait  - ждёт время старта следующего повтора.   work  - выполняет цикл заданий.   pause  - планировщик приостановлен пользователем.   cancel  - остановка выполнения текущего цикла заданий      next_task_start  Строка  Дата и время следующего старта заданий.    remained_cycles  Число  Количество оставшихся повторов заданий. Значение  -1  означает бесконечное повторение.    Tasks  Массив  Статистика заданий.    Поле  tasks  содержит объекты со следующим набором полей:    Поле  Формат  Значение      id  Число  ID задания    name  Строка  Имя задания    start_time  Строка  Время старта задания    end_time  Строка  Последнее время обновления статуса задания    status  Строка  Статус задания. Задание может иметь одно из следующих:   run  - выполняется   pause  - приостановлено   complete  - выполнено   cancel  - отменено   fail  - не выполнено или прервано      count_total  Число  Кол-во документов которые будут обработаны    count_seen  Число  Кол-во документов которые коннектор просмотрел    count_new  Число  Кол-во новых документов    count_differ  Число  Кол-во изменённых документов    count_delete  Число  Кол-во удалённых документов    count_task_error  Число  Кол-во ошибок возникших во время выполнения задания    count_cfs_error  Число  Кол-во ошибок связанных с отправкой документов на CFS    last_doc_id  Строка  ID последнего обработанного документа     Статус complete означает  только одно  - во время выполнения не было внештатных ситуаций. Статус fail же напротив - означает что такая ситуация возникла. Чтобы бы понять качество выполнения задания, проверяйте поля  count_* . '},
{'url0': '/api/control', 'url1': '/api/control#Start', 'title': 'Schedule: Start', 'head': 'Контрольные команды', 'body': ' Старт или возобновление заданий.  Запускает цикл заданий, даже если расписание выключено (см.  [Schedule]: Enable ). Выполнение этих заданий произойдёт один раз в порядке, указанном в настройках.        action= Schedule & cmd = Start        Используя параметр  TaskName  можно запустить одну конкретную задачу:        action= Schedule & cmd = Start & TaskName = FuriKuri        Этот параметр обязателен при возобновлении задания.  Счётчик выполнений  TaskCycles  не учитывает задания запущенные таким образом. Просмотр доступных заданий выполняется командой  TasksInfo . '},
{'url0': '/api/control', 'url1': '/api/control#Pause', 'title': 'Schedule: Pause', 'head': 'Контрольные команды', 'body': ' Приостановка выполнения заданий.  Приостановка выполняется на неограниченное время, однако, отсчёт времени старта до следующего цикла продолжается. Если наступит время выполнения очередного цикла задания во время паузы - запуск будет засчитан счётчиком заданий  TaskCycles , но  цикл будет пропущен, т.к. коннектор не может выполнять несколько заданий одновременно.        action= Schedule & cmd = Pause       '},
{'url0': '/api/control', 'url1': '/api/control#Cancel', 'title': 'Schedule: Cancel', 'head': 'Контрольные команды', 'body': ' Отмена выполнения заданий.  Если во время отмены выполняется задание из цикла, будет прерван весь цикл. При отмене коннектор отправит на CFS всё что успел собрать, но при этом не будет отправлять команду на удаление старых документов.        action= Schedule & cmd = Cancel       '}
]
for (doc in docs){
	index.addDoc(docs[doc]);
}